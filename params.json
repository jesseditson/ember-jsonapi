{
  "name": "ember-jsonapi",
  "tagline": "Create automatic JSONAPI endpoints based on incredibly simple JSON schemas.",
  "body": "### introduction\r\n\r\nember-jsonapi is an ember-cli addon for creating automatic [JSON API](http://jsonapi.org/) endpoints based on shared schemas written in JSON.\r\n\r\nJSON schemas are formatted to be familiar to ember developers, and include the ability to specify ember primitive types as strings, and ember relationship types as objects. A simple schema would look like this:\r\n\r\n**articles.json**\r\n```JSON\r\n{\r\n  \"title\": \"string\",\r\n  \"comments\": {\r\n    \"type\": \"comments\",\r\n    \"relationship\": \"hasMany\"\r\n  }\r\n}\r\n```\r\n\r\nFor full schema API docs, see [the jsonapi-schema API documentation](#todo)\r\n\r\nember-jsonapi comes with blueprints for the following types:\r\n\r\n- **schema** (`ember generate schema [name]`) \r\n\r\nThis creates a schema file and an associated ember model and model unit test.\r\n\r\n- **api** (`ember generate api`)\r\n\r\nThis generates ember-jsonapi server and api files, along with a session service and auth endpoint for authenticating users via [JSON web tokens](https://jwt.io/). This API automatically loads schemas from the application and sets up fully JSON API compatible endpoints under the `/api` endpoint. Additionally, this blueprint prepares the `/server` folder to be production-compatible, so you may deploy the ember application as an express application.\r\n\r\n### concepts\r\n\r\nThe core functionality of this project is broken out into 3 npm modules:\r\n\r\n#### `jsonapi-schema`\r\n\r\nThis module has two responsibilities:\r\n\r\n- Loading schema json files from a local file system and serializing them to a json object.\r\n\r\nIt handles both pod style `app/article/schema.json` and legacy style `app/schemas/article.json` paths, and while intended for use with ember-jsonapi, is framework agnostic.\r\n\r\n- Generating a parser capable of handling simply formatted data and decorating with JSON API structure.\r\n\r\nA simple example of how to use this module is as follows:\r\n\r\n```javascript\r\nvar path = require('path');\r\nvar schema = require('jsonapi-schema');\r\nvar schemas = schema.loadSchemas(path.join(process.cwd(), 'app'));\r\n\r\nvar toJSONAPI = JSONAPI(schemas, '/api');\r\nvar toArticle = toJSONAPI('article');\r\n\r\nvar response = toArticle({\r\n  id: 1,\r\n  title: 'JSON API Paints my bikeshed'\r\n}, {\r\n  included: {\r\n    comments: [\r\n      { id: 5, body: 'First!' }\r\n    ]\r\n  }\r\n})\r\n```\r\n\r\nIn the above example, response would be serialized to the following:\r\n\r\n```\r\n{\r\n  \"links\": {\r\n    \"self\": \"/api/articles\"\r\n  },\r\n  \"data\": [{\r\n    \"type\": \"articles\",\r\n    \"id\": 1,\r\n    \"attributes\": {\r\n      \"title\": \"JSON API paints my bikeshed!\"\r\n    },\r\n    \"relationships\": {\r\n      \"comments\": {\r\n        \"links\": {\r\n          \"self\": \"/api/articles/1/relationships/comments\",\r\n          \"related\": \"/api/articles/1/comments\"\r\n        },\r\n        \"data\": [\r\n          { \"type\": \"comments\", \"id\": 5 }\r\n        ]\r\n      }\r\n    },\r\n    \"links\": {\r\n      \"self\": \"/api/articles/1\"\r\n    }\r\n  }],\r\n  \"included\": [{\r\n    \"type\": \"comments\",\r\n    \"id\": 5,\r\n    \"attributes\": {\r\n      \"body\": \"First!\"\r\n    },\r\n    \"links\": {\r\n      \"self\": \"/api/comments/5\"\r\n    }\r\n  }]\r\n}\r\n```\r\n\r\nThe intent of `jsonapi-schema` is not necessarily to be used in an isolated context, but to provide a simple way of ingesting common relational database responses and serializing them to JSON API documents with as little manipulation as possible.\r\n\r\n#### `jsonapi-express`\r\n\r\nThis module is an express middleware that is generated by passing schemas to it. When called with a schemas object (as generated by `jsonapi-schema` above), it will automatically create endpoints for the passed objects. For instance, building on the above example, you could load your schemas and call it like so:\r\n\r\n```javascript\r\nvar JSONAPI = require('jsonapi-express');\r\nvar schema = require('jsonapi-schema');\r\nvar path = require('path');\r\nvar schemas = schema.loadSchemas(path.join(process.cwd(), 'app'));\r\n\r\nvar operations = {}; // more on operations below\r\n\r\napp.use('/api', JSONAPI(operations, schemas, '/api'));\r\n```\r\n\r\nThe above, when passed our article schema, would create the following endpoints:\r\n\r\n```\r\nGET    /api/articles\r\nGET    /api/articles/:id\r\nPOST   /api/articles\r\nPATCH  /api/articles/:id\r\nDELETE /api/articles/:id\r\nGET    /api/articles/:id/comments\r\nGET    /api/articles/:id/relationships/comments\r\nPOST   /api/articles/:id/relationships/comments\r\nPATCH  /api/articles/:id/relationships/comments\r\nDELETE /api/articles/:id/relationships/comments\r\n```\r\n\r\n`jsonapi-express` handles setting the correct headers, returning the correct error codes, and aims to be a common module that can track against the JSON API spec without having to manually update resource routes in your application.\r\n\r\nTo function though, `jsonapi-express` requires an operations object to be passed in, with the following required keys:\r\n\r\n- `findAll`: a function for finding records\r\n- `findOne`: a function for finding a single record\r\n- `create`:  a function for creating a record\r\n- `delete`:  a function for deleting a record\r\n- `updateRelationship`: a function for updating the relationship between two records\r\n\r\nIn addition, the following optional operations can be passed in:\r\n\r\n- `transforms`: a hash of `[schema name] : [function]` pairs, which is called whenever this record is fetched from the db, before it is parsed by `jsonapi-schema`. This is useful for modifying data without having to specify an if statement inside of a query operation.\r\n- `authorize`: an express middleware that is expected to either call `next` if the user is allowed to access `req.url`, or send a `4xx` if not.\r\n\r\nFor more information on operation method signatures and usage, see the [jsonapi-express documentation](#todo).\r\n\r\n#### `jsonapi-knex`\r\n\r\nThe final piece of `ember-jsonapi` is a preconfigured operations hash. `jsonapi-knex` exports a function that will generate an operations object so you don't have to write your own database queries. It uses [knex.js](http://knexjs.org/) to build sql queries, and as such is compatible with Postgres, MSSQL, MySQL, MariaDB, SQLite3, and Oracle.\r\n\r\nIt is fairly opinionated in the way it requests data, with the only configuration options being the database, schemas, and the option of specifying table names that differ from schema names. It is meant to be a base to build on rather than a comprehensive ORM.\r\n\r\nTo tie all three together (which is what the `api` blueprint does), you'd do the following:\r\n\r\n```\r\nvar JSONAPI = require('jsonapi-express');\r\nvar schema = require('jsonapi-schema');\r\nvar path = require('path');\r\nvar schemas = schema.loadSchemas(path.join(process.cwd(), 'app'));\r\nvar db = require('../lib/db');\r\nvar JSONAPIOperations = require('jsonapi-knex')(db, schemas);\r\n\r\n// add your transforms or modify operations here\r\n\r\napp.use('/api', JSONAPI(JSONAPIOperations, schemas, '/api'));\r\n```\r\n\r\nThe `lib/db.js` file just uses the `knexfile.js` (a knex convention) to load your database config, like so:\r\n\r\n```\r\nvar configs = require('../../knexfile.js')\r\nvar env = process.env.NODE_ENV || 'development'\r\nvar config = configs[env]\r\nif (!config) throw new Error(`No db config defined for environment ${env}`)\r\nmodule.exports = require('knex')(config)\r\n```\r\n\r\n### Getting started guide:\r\n\r\n#### Setup\r\n\r\nTo build an ember application with `ember-jsonapi`, you'd start with an ember application, either an existing one or one generated with `ember init [appname]`.\r\n\r\nThen, install this addon and initialize the api:\r\n\r\n```\r\nember install ember-jsonapi\r\nember generate api\r\n```\r\n\r\nThis creates the files needed to run our JSON API server.\r\n\r\nThe default `knexfile.js` just uses a sqlite database called `dev.sqlite3` in the root of our application. If you'd like to connect to a different database, you can modify this file to your will.\r\n\r\nAlso in the root of the project will be a file called `secrets.json`. It is very important to avoid adding this file to vcs, and it has automatically been added to `.gitignore` to help prevent footgun. This is where you can add your database credentials for staging/production environments. To keep things secure, it's recommended that you change the `jwt_secret` field. Finally, it includes credentials for a seed user that will be created when initializing the database.\r\n\r\n#### Authenticating a user\r\n\r\nThe api blueprint also creates a knex migration & seed to create our user database that our auth will use. To set up our database, first install knex globally, then run our migrations and seeds:\r\n\r\n```\r\nnpm install knex -g\r\nknex migrate:latest\r\nknex seed:run\r\n```\r\n\r\nWe now have a database with a `users` table, and since the api automatically creates a `users` schema and model, you can log a user in via the `session` service.\r\n\r\nTo make this even simpler, `ember-jsonapi` provides a blueprint for creating a simple login screen:\r\n\r\n```\r\nember g login-route\r\n```\r\n\r\nNow, you can run your server using `npm start` or `ember serve`. If you visit [http://localhost:4200/login](http://localhost:4200/login) and enter the credentials in secrets.json, you'll be logged in.\r\n\r\n#### Adding an api endpoint\r\n\r\nAPI endpoints are automatically created based on the existence of schemas, so creating an endpoint is the same task as creating a schema.\r\n\r\nThis library provides a `schema` blueprint to make that task trivial. It accepts the same arguments as ember's built in `model` blueprint, which allows for defining simple types using the command line. Let's create a `todo` schema, which will in turn create a `todo` model, and `todo` endpoints.\r\n\r\n```\r\n$ ember g schema todo text:string done:boolean\r\ninstalling schema\r\n  create app/todo/model.js\r\n  create app/todo/schema.json\r\n  create tests/unit/todo/model-test.js\r\n```\r\n\r\nNow let's edit our schema to add a user relationship:\r\n\r\n```\r\n{\r\n  \"text\": \"string\",\r\n  \"done\": \"boolean\",\r\n  \"owner\": { \"type\": \"users\", \"relationship\": \"belongsTo\" }\r\n}\r\n```\r\n\r\nWe'll need a `todos` table to back our `todo` model, so let's create a knex migration for that:\r\n\r\n```\r\n$ knex migrate:make todos-table\r\nUsing environment: development\r\nCreated Migration: /migrations/20160707154931_todos-table.js\r\n```\r\n\r\nNow we'll update our migration to create our table to match our schema:\r\n\r\n```\r\nexports.up = function(knex, Promise) {\r\n  return knex.schema.createTable('todos', table => {\r\n    table.increments()\r\n    table.string('text')\r\n    table.boolean('done')\r\n    table.integer('owner_id')\r\n    table.foreign('owner_id').references('id').inTable('users')\r\n  })\r\n};\r\n\r\nexports.down = function(knex, Promise) {\r\n  return knex.schema.dropTable('todos')\r\n};\r\n```\r\n\r\nFinally, let's apply our migration by running `knex migrate:latest`, and start our server. Now if you visit [http://localhost:4200/api/todos](http://localhost:4200/api/todos) you'll see that it returns an (empty) list of todos.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}